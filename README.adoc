:sourcedir: .
:last-update-label!:
:icons: font
= LEAF
Low-latency Error Augmentation Framework for C++11
:toclevels: 3
:toc: left
:toc-title:

[abstract]
== Abstract

LEAF is a non-intrusive C++11 error handling library capable of transporting arbitrary error information from contexts that detect and report failures, as well as from intermediate error-neutral contexts, to scopes where the error is ultimately handled.

LEAF does not allocate dynamic memoryfootnote:[Except when transporting error info between threads, see <<capture,`capture`>>.], which makes it suitable for low-latency and other performance-critical environments. It is equally applicable to programs that use exception handling and programs that do not.

[[tutorial]]
== Tutorial

We'll write a program that reads a text file in a buffer and prints it to `std::cout`, using LEAF to handle errors. We'll implement two versions, one that uses exception handling, and one that does not. To see the source code of the complete programs from this tutorial follow these links:

* https://github.com/zajo/leaf/blob/master/example/print_file_eh.cpp[print_file_eh.cpp] (with exception handling)
* https://github.com/zajo/leaf/blob/master/example/print_file_result.cpp[print_file_result.cpp] (without exception handling)

First, let's see how to use LEAF without exception handling.

[[tutorial_noexcept]]
=== Using LEAF without exception handling

We'll write a program that reads a text file in a buffer and prints it to `std::cout`, using LEAF to handle errors. First, we need an `enum` to define our different error codes, and a simple type `e_error_code` to help LEAF tell error codes apart from other `int` values:

====
[source,c++]
----
enum
{
  input_file_open_error,
  input_file_size_error,
  input_file_read_error,
  input_eof_error,
  cout_error
};

struct e_error_code { int value; };
----
====

We don't need an enumerated value that indicates success. That's because we will use the convenient class template `<<result,result>><T>` as the return type in functions which may fail. It is a value-or-error variant type which holds a `T` except if initialized with `leaf::<<error,error>>()`.

Here is a function that reads data from a file into a buffer and reports the various errors which may occur (it returns `result<void>` because in case of success it doesn't return a value):

====
[source,c++]
----
leaf::result<void> file_read( FILE & f, void * buf, int size )
{
  int n = fread(buf,1,size,&f);
  if( ferror(&f) )
    return leaf::error( e_error_code{input_file_read_error}, e_errno{errno} ); <1>

  if( n!=size )
    return leaf::error( e_error_code{input_eof_error} ); <2>

  return { }; <3>
}
----
<1> If `ferror` indicates an error, we return `input_file_read_error` and, because there is a relevant `errno` code, we _also_ pass that to the `leaf::<<error,error>>` constructor (LEAF defines `struct e_errno { int value; }`).
<2> If `fread` reports that it couldn't read all of the data requested, we return `input_eof_error`. In this case there is no relevant `errno` to pass on, because this is not an error as far as `fread` is concerned.
<3> `result<void>` can be initialized with `{ }` to indicate success.
====

NOTE: The `e_error_code` and `e_errno` structs are examples of types that may be passed to the `leaf::error` constructor. The requirement for such types is that they define an accessible data member `value` and `noexcept` move constructor. These types allow us to assign different error-related semantics to different valies of otherwise identical static types. +
 +
For example, we could define `struct e_input_name { std::string value; }` and `struct e_output_name { std::string value; }` and LEAF will treat them as separate entities even though their `.value` members are of the same type `std::string`. +
 +
In this text we refer to such types as `e_` types, because by convention they use the `e_` prefix.

Now, let's consider a possible caller of `file_read`, called `print_file`:

====
[source,c++]
----
leaf::result<void> print_file( char const * file_name )
{
  leaf::result<std::shared_ptr<FILE>> f = file_open(file_name);
  if( !f ) <1>
    return f.error(); <2>

  leaf::preload( e_file_name{file_name} ); <3>

  leaf::result<int> s = file_size(*f.value());
  if( !s ) <4>
    return s.error(); <5>

  std::string buffer( 1+s.value(), '\0' );
  leaf::result<void> fr = file_read(*f.value,&buffer[0],buffer.size()-1);
  if( !fr )
    return fr.error();
  
  std::cout << buffer;
  std::cout.flush();
  if( std::cout.fail() )
    return leaf::error( e_error_code{cout_error} ); <6>

  return { }; <7>
}
----
<1> If `file_open` returns an error...
<2> ...we forward it to the caller.
<3> `<<preload,preload>>` takes any number of `e_` objects and prepares them to become associated with the first `leaf::<<error,error>>` object created thereafter. The effect is that from this point on, all errors returned or forwarded by `print_file` will report the file name, in addition to everything else passed to `leaf::<<error,error>>` explicitly (`e_file_name` is defined as `struct e_file_name { std::string value; }`).
<4> If `file_size` returns an error...
<5> ...we forward it to the caller.
<6> If `std::cout` fails to write the buffer, we return `cout_error`.
<7> Success!
====

Notice the repetitiveness in simply forwarding errors to the caller. LEAF defines two macros, `<<LEAF_AUTO,LEAF_AUTO>>` and `<<LEAF_CHECK,LEAF_CHECK>>`, which can help reduce the clutter:

* The `LEAF_AUTO` macro takes two arguments, an identifier and a `result<T>`. In case the passed `result<T>` indicates an error, `LEAF_AUTO` returns that error to the caller (therefore control leaves the enclosing function). In case of success, `LEAF_AUTO` defines a variable with the specified identifier, of type `T &`, that refers to the `T` object stored inside the passed `result<T>`.

* The `LEAF_CHECK` macro is designed to be used similarly with `result<void>`, but of course it doesn't define a variable.

Below is the same `print_file` function simplified using `LEAF_AUTO` and `LEAF_CHECK` (remember that the variables defined by `LEAF_AUTO` are not of type `result<T>`, but of type `T &`; for example `s` used to be `result<int>`, but now it is simply `int &`):

====
[source,c++]
----
leaf::result<void> print_file( char const * file_name )
{
  LEAF_AUTO(f,file_open(file_name)); <1>

  leaf::preload( e_file_name{file_name} );

  LEAF_AUTO(s,file_size(*f)); <2>

  std::string buffer( 1+s, '\0' );
  LEAF_CHECK(file_read(*f,&buffer[0],buffer.size()-1)); <3>

  std::cout << buffer;
  std::cout.flush();
  if( std::cout.fail() )
    return leaf::error( e_error_code{cout_error} );

  return { };
}
----
<1> Call `file_open`, check for errors, unpack the returned `result<std::shared_ptr<FILE>>` and define a variable `f` of type `std::shared_ptr<FILE> &` that refers to it.
<2> Call `file_size`, check for errors, unpack the returned `result<int>` and define a variable `s` of type `int &` that refers to it.
<3> Call `file_read`, check for errors (`file_read` returns `result<void>`).
====

Finally, let's consider the `main` function, which is able to handle errors reported by `print_file`:

====
[source,c++]
----
int main( int argc, char const * argv[ ] )
{
  char const * fn = parse_command_line(argc,argv);
  if( !fn )
  {
    std::cout << "Bad command line argument" << std::endl;
    return 1;
  }

  leaf::expect<e_error_code, e_file_name, e_errno> exp; <1>

  if( auto r = print_file(fn) )
  {
    return 0; <2>
  }
  else
  {
    switch( auto ec = *leaf::peek<e_error_code>(exp,r) ) <3>
    {
      case input_file_open_error:
      {
        bool matched = handle_error( exp, r, <4>

          leaf::match<e_file_name,e_errno>( [ ] ( std::string const & fn, int errn )
          {
            if( errn==ENOENT )
              std::cerr << "File not found: " << fn << std::endl;
            else
              std::cerr << "Failed to open " << fn << ", errno=" << errn << std::endl;
          } )

        );
        assert(matched);
        return 2;
      }

      case input_file_size_error:
      case input_file_read_error:
      case input_eof_error:
      {
        bool matched = handle_error( exp, r, <5>

          leaf::match<e_file_name,e_errno>( [ ] ( std::string const & fn, int errn )
          {
            std::cerr << "Failed to access " << fn << ", errno=" << errn << std::endl;
          } ),

          leaf::match<e_errno>( [ ] ( int errn )
          {
            std::cerr << "I/O error, errno=" << errn << std::endl;
          } ),

          leaf::match<>( [ ]
          {
            std::cerr << "I/O error" << std::endl;
          } )

        );
        assert(matched);
        return 3;
      }

      case cout_error:
      {
        bool matched = handle_error( exp, r, <6>

          leaf::match<e_errno>( [ ] ( int errn )
          {
            std::cerr << "Output error, errno=" << errn << std::endl;
          } )

        );
        assert(matched);
        return 4;
      }

      default:
        std::cerr << "Unknown error code " << int(ec) << ", cryptic information follows." << std::endl; <7>
        diagnostic_print(std::cerr,exp,r);
        return 5;
    }
  }
}
----
<1> We expect `e_error_code`, `e_file_name` and `e_errno` objects to arrive with errors handled in this function. They will be stored inside exp.
<2> Success, we're done!
<3> Probe `exp` for objects associated with the error stored in `r`.
<4> `<<handle_error,handle_error>>` takes a list of match objects (in this case only one), each given a set of `e_ types`. It attempts to match each set (in order) to objects of `e_` types, associated with `r`, available in `exp`. If no set can be matched, `handle_error` returns false. When a match is found, `handle_error` calls the corresponding lambda, passing the `.value` of each of the `e_` types from the matched set.
<5> In this case `handle_error` is given 3 match sets. It will first check if both `e_file_name` and `e_errno`, associated with `r`, are avialable in `exp`; if not, it will next check if just `e_errno` is available; and if not, the last (empty) set will always match to print a generic error message.
<6> Report failure to write to `std::cout`, print the relevant errno.
<7> This catch-all case helps diagnose logic errors (presumably, missing case labels in the `switch` statement).
====

To summarize, when using LEAF without exception handling:

* Functions that may fail return instances of `<<result,result>><T>`, a value-or-error variant class template.
* In case a function detects a failure, the returned `result<T>` can be initialized implicitly by returning `leaf::<<error,error>>`, which is passed any and all information we have that is relevant to the failure.
* When a lower level function reports an error, that error is forwarded to the caller, passing any additional relevant information available in the current scope.
* In order for any object passed to `leaf::<<error,error>>` to be used at all, the function that handles the error must contain an instance of the class template `<<expect,expect>>` that provides the necessary storage for that object's type.
* Using `<<handle_error,handle_error>>`, functions that handle errors can easily match available `e_` types to what they require in order to deal with each failure.

NOTE: The complete program from this tutorial is available https://github.com/zajo/leaf/blob/master/example/print_file_result.cpp[here]. There is also https://github.com/zajo/leaf/blob/master/example/print_file_eh.cpp[another] version of the same program that uses exception handling to report errors (see <<tutorial_eh,tutorial below>>).


'''

[[tutorial_eh]]
=== Using LEAF with exception handling

And now, we'll write the same program that reads a text file in a buffer and prints it to `std::cout`, this time using exception handling. First, we need to define our exception class hierarchy:

====
[source,c++]
----
struct print_file_error : virtual std::exception { };
struct command_line_error : virtual print_file_error { };
struct bad_command_line : virtual command_line_error { };
struct input_error : virtual print_file_error { };
struct input_file_error : virtual input_error { };
struct input_file_open_error : virtual input_file_error { };
struct input_file_size_error : virtual input_file_error { };
struct input_file_read_error : virtual input_file_error { };
struct input_eof_error : virtual input_file_error { };
----
====

Here is a function that reads data from a file into a buffer and reports the various errors which may occur:

====
[source,c++]
----
void file_read( FILE & f, void * buf, int size )
{
  int n = fread(buf,1,size,&f);

  if( ferror(&f) )
    leaf::throw_exception( input_file_read_error(), e_errno{errno} ); <1>

  if( n!=size )
    throw input_eof_error(); <2>
}
----
<1> If `ferror` indicates an error, we throw `input_file_read_error` and, because there is a relevant `errno` code, we pass that to `<<throw_exception,throw_exception>>` _also_ (LEAF defines `struct e_errno { int value; }`).
<2> If `fread` reports that it couldn't read all of the data requested, we throw `input_eof_error`. In this case there is no relevant `errno` to pass on, because this is not an error as far as `fread` is concerned.
====

NOTE: The `e_error_code` and `e_errno` structs are examples of types that may be passed to `leaf::<<throw_exception,throw_exception>>` (and to the `leaf::error` constructor). The requirement for such types is that they define an accessible data member `value` and `noexcept` move constructor. These types allow us to assign different error-related semantics to different valies of otherwise identical static types. +
 +
For example, we could define `struct e_input_name { std::string value; }` and `struct e_output_name { std::string value; }` and LEAF will treat them as separate entities even though their `.value` members are of the same type `std::string`. +
 +
In this text we refer to such types as `e_` types, because by convention they use the `e_` prefix.

Now, let's consider a possible caller of `file_read`, called `print_file`:

====
[source,c++]
----
void print_file( char const * file_name )
{
  std::shared_ptr<FILE> f = file_open( file_name ); <1>

  leaf::preload( e_file_name{file_name} ); <2>

  std::string buffer( 1+file_size(*f), '\0' ); <3>
  file_read(*f,&buffer[0],buffer.size()-1);

  auto propagate = leaf::defer([ ] { return e_errno{errno}; } ); <4>
  std::cout << buffer;
  std::cout.flush();
}
----
<1> `std::shared_ptr<FILE> file_open( char const * file_name)` throws on error.
<2> `<<preload,preload>>` takes any number of `e_` objects and prepares them to become associated with the first exception thrown thereafter. The effect is that from this point on, any exception escaping `print_file` will report the file name, in addition to everything else passed to `<<throw_exception,throw_exception>>` explicitly (`e_file_name` is defined as `struct e_file_name { std::string value; }`).
<3> `int file_size( FILE & f )` throws on error.
<4> `<<defer,defer>>` is similar to `preload`: it prepares an `e_` object to become associated with the first exception thrown thereafter, but instead of taking the `e_` object itself, `defer` takes a function that returns it. The function is invoked in the returned object`s destructor, at which point it becomes associated with the exception being propagated. Assuming `std::cout` is configured to throw on error, the effect is that those exceptions will have the relevant `errno` associated with them.
====

Finally, let's consider the `main` function, which is able to handle exceptions thrown by `print_file`:

====
[source,c++]
----
int main( int argc, char const * argv[ ] )
{
   std::cout.exceptions ( std::ostream::failbit | std::ostream::badbit ); <1>
 
  leaf::expect<e_file_name, e_errno> exp; <2>

  try
  {
    print_file(parse_command_line(argc,argv));
    return 0;
  }
  catch( bad_command_line const & )
  {
    std::cout << "Bad command line argument" << std::endl;
    return 1;
  }
  catch( input_file_open_error const & ex )
  {
    handle_exception( exp, ex, <3>

      leaf::match<e_file_name, e_errno>( [ ] ( std::string const & fn, int errn )
      {
        if( errn==ENOENT )
          std::cerr << "File not found: " << fn << std::endl;
        else
          std::cerr << "Failed to open " << fn << ", errno=" << errn << std::endl;
      } )

    );
    return 2;
  }
  catch( input_error const & ex )
  {
    handle_exception( exp, ex, <4>

      leaf::match<e_file_name, e_errno>( [ ] ( std::string const & fn, int errn )
      {
        std::cerr << "Input error, " << fn << ", errno=" << errn << std::endl;
      } ),

      leaf::match<e_errno>( [ ] ( int errn )
      {
        std::cerr << "Input error, errno=" << errn << std::endl;
      } ),

      leaf::match<>( [ ]
      {
        std::cerr << "Input error" << std::endl;
      } )

    );
    return 3;
  }
  catch( std::ostream::failure const & ex )
  {
    //Report failure to write to std::cout, print the relevant errno, if available.
    handle_exception( exp, ex,

      leaf::match<e_errno>( [ ] ( int errn )
      {
        std::cerr << "Output error, errno=" << errn << std::endl;
      } )

    );
    return 4;
  }
  catch(...) <5>
  {
    std::cerr << "Unknown error, cryptic information follows." << std::endl; 
    current_exception_diagnostic_print(std::cerr,exp);
    return 5;
  }
}
----
<1> Configure `std::cout` to throw on error.
<2> We expect `e_file_name` and `e_errno` objects to arrive with errors handled in this function. They will be stored inside `exp`.
<3> `<<handle_exception,handle_exception>>` takes a list of match objects (in this case only one), each given a set of `e_` types. It attempts to match each set (in order) to objects of `e_` types, associated with `ex`, available in `exp`. If no set can be matched, `handle_exception` rethrows the current exception. When a match is found,
`handle_exception` calls the corresponding lambda, passing the `.value` of each of the `e_` types from the matched set.
<4> In this case `handle_exception` is given 3 match sets. It will first check if both `e_file_name` and `e_errno`, associated with `ex`, are avialable in `exp`; if not, it will next check if just `e_errno` is available; and if not, the last (empty) set will always match to print a generic error message.
<5> This catch-all is designed to help diagnose logic errors (main should be able to deal with any failures).
====

To summarize, when using LEAF with exception handling:

* In case a function detects a failure, it may use `<<throw_exception,throw_exception>>`, passing (in addition to the exception object) any number of `e_` objects, to associate with the exception any information it has that is relevant to the failure. Alternatively it may use `<<preload,preload>>` to associate `e_` objects with any exception thrown later on, including exceptions thrown by third-party code.
* In order for any object passed to `<<throw_exception,throw_exception>>` to be stored at all, the function that catches the exception must contain an instance of the class template `<<expect,expect>>` that provides the necessary storage for that object's type.
* Using `<<handle_exception,handle_exception>>`, functions that handle exceptions can easily match available `e_` types to what they require in order to deal with each failure.

NOTE: The complete program from this tutorial is available https://github.com/zajo/leaf/blob/master/example/print_file_eh.cpp[here]. There is also https://github.com/zajo/leaf/blob/master/example/print_file_result.cpp[another] version of the same program that does not use exception handling to report errors (see <<tutorial_noexcept,previous tutorial>>).

[[reference]]
== Reference

[[expect]]
=== Class template `expect`

====
.#include <boost/leaf/expect.hpp>
[source,c++]
----
namespace boost { namespace leaf {

  template <class... E>
  class expect
  {
  public:

    expect() noexcept;
    ~expect() noexcept;

    template <class... M>
    friend bool handle_error( expect & exp, error const & e, M && ... m ) noexcept;

    friend void diagnostic_print( std::ostream & os, expect const & exp );
    friend void diagnostic_print( std::ostream & os, expect const & exp, error const & e );

    friend error_capture capture( expect & exp, error const & e );

    void propagate() noexcept;

  };

  template <class P,class... E>
  decltype(P::value) const * peek( expect<E...> const & exp, error const & e ) noexcept;

} }
----
====

Objects of type `expect<E...>` are not copyable and are not movable. All `expect` objects must use automatic storage duration. The specified `E...` types must be user-defined (e.g. structs), with `noexcept` move semantics, that define accessible data member called `value`. For example:

[source,c++]
----
struct e_file_name { std::string value; };
----

In this text such types are referred to as `e_` types, because by convention they use the `e_` prefix. Similarly, instances of `e_` types are called `e_` objects.

An `expect<E...>` object contains _slots_, each slot providing storage for objects of one of the specified `E` arguments. It is invalid to include the same type twice in the `E...` parameter pack. Thus, each type `E` uniquely identifies an `expect` slot. All slots are initially empty.

Slots of the same type `E` across different `expect` objects (that belong to the calling thread)  form a stack. When an `e_` object is passed to the `leaf::<<error,error>>` constructor, it is moved into the corresponding slot on the top of that stack, and is associated with that `leaf::error` value. If no `expect` objects contain a corresponding slot, the `e_` object passed to the `leaf::error` constructor is discarded.

An `e_` object stored in an `expect` slot can be accessed in several different ways, all requiring the `leaf::error` value it was associated with. While an `expect` object can not store multiple values of the same `e_` type, this association guarantees that the returned `e_` object pertains to that specific `error` value.

Iff an error was successfully handled (a call to `<<handle_error,handle_error>>` returned `true`), then `~expect()` discards all stored `e_` objects. Otherwise, each stored `e_` object is moved to the corresponding slot one level below the top of the stack formed by the slots of the same `e_` type across different `expect` objects. If that stack is empty, the `e_` object is discarded.

'''

[[expect_ctor]]
==== `expect()`

.#include <boost/leaf/expect.hpp>
[source,c++]
----
namespace boost { namespace leaf {

  template <class... E>
  expect<E...>::expect() noexcept;

} }
----

Description: :: Initializes an empty `expect` instance.

Postconditions: :: `<<peek,peek>><P>(*this,e)` returns `0` for any `P` and any `<<error,error>>` value `e`.

'''

[[expect_dtor]]
==== `~expect()`

.#include <boost/leaf/expect.hpp>
[source,c++]
----
namespace boost { namespace leaf {

  template <class... E>
  expect<E...>::~expect() noexcept;

} }
----

Effects: :: If a previous call to `<<handle_error,handle_error>>` for `*this` succeeded (returned `true`), all objects currently stored in `*this` are discarded. Otherwise the stored objects are moved to corresponding slots in other existing `expect` instances according to the rules described `<<expect,here>>`.

NOTE: Calling `<<propagate,propagate>>` after a successful call to `handle_error` restores the original behavior of `~expect`.

'''

[[peek]]
==== `peek()`

.#include <boost/leaf/expect.hpp>
[source,c++]
----
namespace boost { namespace leaf {

  template <class P,class... E>
  decltype(P::value) const * peek( expect<E...> const & exp, error const & e ) noexcept;

} }
----

Returns: :: If `exp` currently stores an object of type `P` associated with the `<<error,error>>` value `e`, returns a read-only pointer to that object. Otherwise returns `0`.

'''

[[handle_error]]
==== `handle_error()`

.#include <boost/leaf/expect.hpp>
[source,c++]
----
namespace boost { namespace leaf {

  template <class... M>
  friend bool handle_error( expect & exp, error const & e, M && ... m ) noexcept;

} }
----

Effects: :: Each of the `m...` objects must have been obtained by a separate call to the function template `<<match,match>>`, each time instantiated with a different set of `e_` types, and passed a different lambda function. +
+
The call to `handle_error` attempts to match the set of `e_` types from each of the `m...` objects, in order, to the types of `e_` objects, associated with the `<<error,error>>` value `e`, currently stored in `exp`. +
+
If a complete match is found among `m...`:
+
--
* Its lambda function is called with the `.value` members of the entire set of matching `e_` objects from `exp`, associated with `e`;
* `exp` is marked so that `<<expect_dtor,~expect>>` will destroy all of the stored `e_` objects (this can be undone by a later call to `<<propagate,propagate>>`);
* `handle_error` returns true.
--
+
Otherwise, `handle_error` returns false.

Example: ::
+
[source,c++]
----
bool matched = handle_error( exp, e,

  leaf::match<e_file_name,e_errno>( [ ] ( std::string const & fn, int errn )
  {
    std::cerr << "Failed to access " << fn << ", errno=" << errn << std::endl;
  } ),

  leaf::match<e_errno>( [ ] ( int errn )
  {
    std::cerr << "I/O error, errno=" << errn << std::endl;
  } )

);
----
+
Assuming `struct e_file_name { std::string value; }` and `struct e_errno { int value; }`, the call to `handle_error` above will: +
+
* Check if the `expect` object `exp` contains `e_file_name` and `e_errno` objects, associated with the `leaf::<<error,error>>` value `e`. If it does, it will pass them to the lambda function passed in the first call to `<<match,match>>`, then return `true`;
* Otherwise if it contains just `e_errno`, it will pass it to the lambda function passed in the second call to `match`, then return `true`;
* Otherwise, `handle_error` returns `false`.

'''

[[diagnostic_print]]
==== `diagnostic_print()`

.#include <boost/leaf/expect.hpp>
[source,c++]
----
namespace boost { namespace leaf {

  template <class... E>
  void diagnostic_print( std::ostream & os, expect<E...> const & exp );

  template <class... E>
  void diagnostic_print( std::ostream & os, expect<E...> const & exp, error const & e );

} }
----

Effects: :: Prints diagnostic information about the `e_` values stored in `exp`. The second overload will only print diagnostic information about `e_` values stored in `exp`, associated with the `leaf::<<error,error>>` value `e`.

[NOTE]
--
The diagnostic information is printed by calls to `operator<<` overloads, statically bound at the time each `e_` object is passed to `leaf::<<error,error>>` constructor. The following overloads are attempted, in order:

. `operator<<` that can be called with a `std::ostream &` and the `e_` object itself (the enclosing struct, not its `.value`);
. `operator<<` that can be called with a `std::ostream &` and the `e_` object's `.value` member.

If neither overload can be bound, diagnostic information about that particular `e_` object can not be printed. This is okay, the program is still well formed.
--

'''

[[capture]]
==== `capture()`

.#include <boost/leaf/expect.hpp>
[source,c++]
----
namespace boost { namespace leaf {

  template <class... E>
  error_capture capture( expect<E...> & exp, error const & e );

} }
----

Effects: :: Moves all `e_` objects currently stored in `exp`, associated with the `leaf::<<error,error>>` value `e`, into the returned `<<error_capture,error_capture>>` object. The contents of the `error_capture` object is immutable and allocated on the heap.

NOTE: `error_capture` objects are useful for transporting `e_` objects to a different thread.

'''

[[propagate]]
==== `propagate()`

.#include <boost/leaf/expect.hpp>
[source,c++]
----
namespace boost { namespace leaf {

  template <class... E>
  void expect<E...>::propagate() noexcept;

} }
----

Effects: :: This function can be used after a successful call to `<<handle_error,handle_error>>`, to restore the original state of `*this`, in which `~expect()` will propagate all contained `e_` objects to other `expect` instances, as explained <<expect,here>>.

'''

[[error]]
=== Class `error`

====
.#include <boost/leaf/error.hpp>
[source,c++]
----
namespace boost { namespace leaf {

  class error
  {
  public:

    error() noexcept:

    template <class... E>
    explicit error( E && ... e ) noexcept:

    template <class... E>
    error propagate( E && ... e ) const noexcept;

    friend bool operator==( error const & e1, error const & e2 ) noexcept;
    friend bool operator!=( error const & e1, error const & e2 ) noexcept;

    friend std::ostream & operator<<( std::ostream & os, error const & e )
 
  };

} }
----
====

Objects of class `error` are values that identify a errors across the entire program. They can be copied, moved, assigned to, and compared to other error objects. They occupy as much memory as `unsigned int`, and are as fast.

Whenever an `e...` sequence is passedo `error` functions, these objects are moved into matching storage provided by `<<expect,expect>>` instances and associated with the `error` object, which can later be passed to `<<peek,peek>>` or `<<handle_error,handle_error>>` to retrieve them.

'''

==== `error()`

.#include <boost/leaf/error.hpp>
[source,c++]
----
namespace boost [ namespace leaf {

  error::error() noexcept:

  template <class... E>
  explicit error::error( E && ... e ) noexcept;

} }
----

Effects: :: Moves each of the `e...` objects into matching storage provided by `expect` instances. See `<<expect,expect>>`.

Postconditions: :: `*this` is a unique value across the entire program. The user may create any number of other `error` values that compare equal to `*this`, by copy, move or assignment, just like with any other value type.

'''

==== `operator==()`

.#include <boost/leaf/error.hpp>
[source,c++]
----
namespace boost [ namespace leaf {

  friend bool operator==( error const & e1, error const & e2 ) noexcept;

} }
----

Returns: :: `true` if the two values `e1` and `e2` are equal, `false` otherwise.

'''

==== `operator!=()`

.#include <boost/leaf/error.hpp>
[source,c++]
----
namespace boost [ namespace leaf {

  friend bool operator!=( error const & e1, error const & e2 ) noexcept;

} }
----

Returns: :: `!(e1==e2)`.

'''

==== `operator<<()`

.#include <boost/leaf/error.hpp>
[source,c++]
----
namespace boost [ namespace leaf {

  friend std::ostream & operator<<( std::ostream & os, error const & e )

} }
----

Effects: :: Prints a `unsigned int` value that uniquely identifies the value `e`.

'''

=== Class `error_capture`

====
.#include <boost/leaf/error_capture.hpp>
[source,c++]
----

namespace boost [ namespace leaf {

  class error_capture
  {
  public:

    error_capture() noexcept;

    explicit operator bool() const noexcept;

    error propagate() noexcept;

    template <class... M>
    friend bool handle_error( error_capture const & e, M && ... m ) noexcept;

    friend void diagnostic_print( std::ostream & os, error_capture const & e );

  };

  template <class P>
  decltype(P::value) const * peek( error_capture const & ec ) noexcept;

} }

----
====

Objects of class `error_capture` are similar to `<<expect,expect>>` instances in that they contain `e_` objects and can be examined by (their own overloads of) `peek` and `handle_error`. However, unlike `expect` objects, `error_capture` objects:

* are immutable;
* are allocated on the heap;
* associate all of their `e_` objects with exactly one `error` value;
* when probed with `peek`/`handle_error`, the lookup is dynamic;
* define `noexcept` copy/move/assignment operations.

The default constructor can be used to initialize an empty `error_capture`. Use `<<capture,capture>>` to capture all `e_` objects associated with a given `error` value from a given `expect` object.

[NOTE]
--
Typical use of `error_capture` objects is to transport `e_` objects across threads, however they are rarely used directly. Instead:

* With exception handling, use `<<capture_exception,capture_exception>>` / `<<get,get>>`;
* Without exception handling, simply return a <<result::capture,captured>> `result<T>` from a worker thread.
--

'''

==== `error_capture()`

.#include <boost/leaf/error_capture.hpp>
[source,c++]
----

namespace boost [ namespace leaf {

  error_capture::error_capture() noexcept;

} }

----

'''

==== `operator bool()`

.#include <boost/leaf/error_capture.hpp>
[source,c++]
----

namespace boost [ namespace leaf {

  error_capture::operator bool() const noexcept;

} }

----

'''

==== `propagate()`

.#include <boost/leaf/error_capture.hpp>
[source,c++]
----

namespace boost [ namespace leaf {

  error error_capture::propagate() noexcept;

} }

----

'''

==== `peek()`

.#include <boost/leaf/error_capture.hpp>
[source,c++]
----

namespace boost [ namespace leaf {

  template <class P>
  decltype(P::value) const * peek( error_capture const & ec ) noexcept;

} }

----

'''

==== `handle_error()`

.#include <boost/leaf/error_capture.hpp>
[source,c++]
----

namespace boost [ namespace leaf {

  template <class... M>
  friend bool error_capture::handle_error( error_capture const & e, M && ... m ) noexcept;

} }

----

'''

==== `diagnostic_print()`

.#include <boost/leaf/error_capture.hpp>
[source,c++]
----

namespace boost [ namespace leaf {

  friend void diagnostic_print( std::ostream & os, error_capture const & e );

} }

----

'''

=== Class template `result`

.#include <boost/leaf/result.hpp>
[source,c++]
----
namespace boost [ namespace leaf {

  template <class T>
  result
  {
  public:

    result() noexcept;
    result( T const & v );
    result( T && v ) noexcept;
    result( leaf::error const & e ) noexcept;
    result( leaf::error_capture const & cap ) noexcept:;

    void reset( T const & v );
    void reset( T && v ) noexcept;
    void reset( leaf::error const & e ) noexcept;
    void reset( leaf::error_capture const & cap ) noexcept;

    explicit operator bool() const noexcept;

    T const & value() const;
    T & value();
    T const & operator*() const;
    T & operator*();

    template <class... E>
    leaf::error error( E && ... e ) noexcept;

    template <class... E>
    friend result && capture( expect<E...> & exp, result && r );

    template <class... M,class... E>
    friend bool handle_error( expect<E...> & exp, result & r, M && ... m ) noexcept;

    template <class... E>
    friend void diagnostic_print( std::ostream & os, expect<E...> const & exp, result const & r );

 };

  template <class P,class... E,class T>
  decltype(P::value) const * peek( expect<E...> const &, result<T> const & ) noexcept;

} }
----

'''

==== `result()`

.#include <boost/leaf/result.hpp>
[source,c++]
----
namespace boost [ namespace leaf {

  result::result() noexcept;
  result::result( T const & v );
  result::result( T && v ) noexcept;
  result::result( leaf::error const & e ) noexcept;
  result::result( leaf::error_capture const & cap ) noexcept:;

} }
----

'''

'''

==== `reset()`

.#include <boost/leaf/result.hpp>
[source,c++]
----
namespace boost [ namespace leaf {

  void result::reset( T const & v );
  void result::reset( T && v ) noexcept;
  void result::reset( leaf::error const & e ) noexcept;
  void result::reset( leaf::error_capture const & cap ) noexcept;

} }
----

'''

==== `operator bool()`

.#include <boost/leaf/result.hpp>
[source,c++]
----
namespace boost [ namespace leaf {

  result::operator bool() const noexcept;

} }
----

'''

==== `value()`

.#include <boost/leaf/result.hpp>
[source,c++]
----
namespace boost [ namespace leaf {

  T const & result::value() const;
  T & result::value();

} }
----

'''

==== `operator*()`

.#include <boost/leaf/result.hpp>
[source,c++]
----
namespace boost [ namespace leaf {

  T const & result::operator*() const;
  T & result::operator*();

} }
----

'''

==== `error()`

.#include <boost/leaf/result.hpp>
[source,c++]
----
namespace boost [ namespace leaf {

  template <class... E>
  leaf::error result::error( E && ... e ) noexcept;

} }
----

'''

==== `capture()`

.#include <boost/leaf/result.hpp>
[source,c++]
----
namespace boost [ namespace leaf {

  template <class... E>
  friend result && result::capture( expect<E...> & exp, result && r );

} }
----

'''

==== `peek()`

.#include <boost/leaf/result.hpp>
[source,c++]
----
namespace boost [ namespace leaf {

  template <class P,class... E,class T>
  decltype(P::value) const * peek( expect<E...> const &, result<T> const & ) noexcept;

} }
----

'''

==== `handle_error()`

.#include <boost/leaf/result.hpp>
[source,c++]
----
namespace boost [ namespace leaf {

  template <class... M,class... E>
  friend bool result::handle_error( expect<E...> & exp, result & r, M && ... m ) noexcept;

} }
----

'''

==== `diagnostic_print()`

.#include <boost/leaf/result.hpp>
[source,c++]
----
namespace boost [ namespace leaf {

  template <class... E>
  friend void result::diagnostic_print( std::ostream & os, expect<E...> const & exp, result const & r );

} }
----

'''

=== Exception handling functions

====
[source,c++]
.#include <boost/leaf/exception.hpp>
----
namespace boost { namespace leaf {

  template <class P,class... E>
  decltype(P::value) const * peek( expect<E...> const & exp, std::exception const & e ) noexcept;

  template <class... M,class... E>
  void handle_exception( expect<E...> & exp, std::exception const & e, M && ... m );

  template <class... E>
  void diagnostic_print( std::ostream & os, expect<E...> const & exp, std::exception const & e );

} }
----

.#include <boost/leaf/exception_capture.hpp>
----
namespace boost { namespace leaf {

  template <class... E,class F>
  leaf_detail::exception_trap<F,E...> capture_exception( F && f ) noexcept;

  template <class Future>
  decltype(std::declval<Future>().get()) get( Future && f );

} }
----

.#include <boost/leaf/throw_exception.hpp>
----
namespace boost { namespace leaf {

  template <class... E,class Ex>
  [[noreturn]] void throw_exception( Ex && ex, E && ... e );

  template <class... E,class Ex>
  [[noreturn]] void throw_exception( Ex && ex, error const & err, E && ... e );

} }
----
====

'''

==== `peek()`

[source,c++]
.#include <boost/leaf/exception.hpp>
----
namespace boost { namespace leaf {

  template <class P,class... E>
  decltype(P::value) const * peek( expect<E...> const & exp, std::exception const & e ) noexcept;

} }
----

'''

==== `handle_exception()`

[source,c++]
.#include <boost/leaf/exception.hpp>
----
namespace boost { namespace leaf {

  template <class... M,class... E>
  void handle_exception( expect<E...> & exp, std::exception const & e, M && ... m );

} }
----

'''

==== `diagnostic_print()`

[source,c++]
.#include <boost/leaf/exception.hpp>
----
namespace boost { namespace leaf {

  template <class... E>
  void diagnostic_print( std::ostream & os, expect<E...> const & exp, std::exception const & e );

} }
----

'''

==== `capture_exception()`

[source,c++]
.#include <boost/leaf/exception_capture.hpp>
----
namespace boost { namespace leaf {

  template <class... E,class F>
  leaf_detail::exception_trap<F,E...> capture_exception( F && f ) noexcept;

} }
----

'''

==== `get()`

[source,c++]
.#include <boost/leaf/exception_capture.hpp>
----
namespace boost { namespace leaf {

  template <class Future>
  decltype(std::declval<Future>().get()) get( Future && f );

} }
----

'''

==== `throw_exception()`

[source,c++]
.#include <boost/leaf/throw_exception.hpp>
----
namespace boost { namespace leaf {

  template <class... E,class Ex>
  [[noreturn]] void throw_exception( Ex && ex, E && ... e );

  template <class... E,class Ex>
  [[noreturn]] void throw_exception( Ex && ex, error const & err, E && ... e );

} }
----

'''

[[common]]
=== Common `e_` types

====
.#include <boost/leaf/common.hpp>
[source,c++]
----
namespace boost { namespace leaf {

  struct e_api_function { char const * value; };
  struct e_file_name { std::string value; };

  struct e_errno {
    int value;
    friend std::ostream & operator<<( std::ostream & os, e_errno const & err );
  };

  e_errno get_errno() noexcept {
    return e_errno { errno };
  }

} }
----
====

This header defines some common error info objects which can be used directly:

- The `e_api_function` type is designed to capture the name of the function for which a failure is reported. For example, if you're reporting an error detected by `fread`, you could use `leaf::e_api_function { "fread" }`.
+
WARNING: The passed value is stored as a C string, so you should only pass string literals for `value`.
- When a file operation fails, you could use `e_file_name` to capture the name of the file.
- `e_errno` is suitable to capture `errno`.
+
TIP: If using `<<preload,preload>>`, pass `&get_errno` instead of an instance of `e_errno`; this way `errno` will be captured after the error is detected, rather than at the time `preload` is called.
+
NOTE: `e_errno` objects can be streamed to a `std::ostream`, which uses `strerror` to convert the `errno` code to a friendlier error message. This is designed for use with `<<diagnostic_information,diagnostic_information>>`.

[[techniques]]
== Programming Techniques

=== Capturing `errno` with `preload`

Typically, when calling `<<preload,preload>>` we pass the actual error info object(s) that we want forwarded to `<<put,put>>`. This copies them into the returned temporary object. Later, if we report an error from the same function, the destructor of the temporary object will forward all of its contents to `<<put,put>>` by rvalue reference.

But this behavior is incorrect for capturing `errno`. Consider:

[source,c++]
----
error read_file( FILE & f ) {
  auto put = leaf::preload( e_errno { errno } ); //incorrect
  ....
  if( ferror(&f) )
    return my_error;
}
----

The problem is that `errno` must not be captured before it is set by a failed operation. The solution is to instead pass a function to `preload`:

[source,c++]
----
error read_file( FILE & f ) {
  auto put = leaf::preload( [ ] { return e_errno { errno }; );
  ....
  if( ferror(&f) )
    return my_error;
}
----

When `preload` is passed a function, obtaining the error info object is deferred until the temporary object is being destroyed.

TIP: The header `boost/leaf/common.hpp` defines a function called `get_errno` which can be used for capturing `errno`, rather than using a lambda each time.

=== Transporting Error Information between Threads

The memory provided by `<<expect,expect>>` for `<<put,put>>` to store error info objects uses thread-local storage. This is ideal when errors are handled before the reporting thread ends, but sometimes error handling must happen in another thread, at the time a worker thread is joined.

The first problem is that in the spirit of LEAF, the context that handles errors is the one specifying what info it needs, by calling `<<expect,expect>>`, which in this case should be controlled by the main thread. This is achieved by instantiating the function template `<<transport,transport>>` instead of `expect`: it takes a function object (the worker thread function), and returns a function object that calls it after calling `expect` internally.

Secondly, to capture the current error info detached from the calling thread, create an object of class `<<capture,capture>>`. This moves all error info from thread-local to dynamically-allocated memory controlled by that object. The `noexcept` move constructor can now be used to move the error info to the main thread. Next, call `<<release,release>>` to once more move the captured error info to thread-local storage in the new thread.

This approach requires that a worker thread returns a variant type which can either hold the result in case of success, or an error code + a `capture` instance in case of error. This is illustrated with the https://github.com/zajo/leaf/blob/master/example/print_file_ec.cpp[print_file_ec.cpp] example.

A cleaner solution is possible if worker threads communicate errors by throwing exceptions. In this case you don't have to deal with the `capture` class directly: simply wrap the thread function in a call to `transport`, and later pass the `std::future` object to `leaf::<<get,get>>` to retrieve the result. This is illustrated with the https://github.com/zajo/leaf/blob/master/example/print_file_eh.cpp[print_file_eh.cpp] example.

== Design Rationale

The first observation driving the LEAF design is that unless a specific type of info (e.g. a file name) is used at the time an error is being handled, there is no need for it to be reported. On the other hand, if the error handling context can use or requires some info, it would not be burdened by having to explicitly declare that need. The end result of this reasoning is `<<expect,expect>>`/`<<put,put>>`.

The second observation is that ideally, like any other communication mechanism, it makes sense to formally define an interface for the error info that can be used by the error handling code. In terms of C++ exception handling, it would be nice to be able to say something like:

[source,c++]
----
try {

  process_file();

} catch( file_read_error<e_file_name,e_errno> & e ) {

  std::cerr <<
    "Could not read " << e.get<e_file_name>() <<
    ", errno=" << e.get<e_errno>() << std::endl;

} catch( file_read_error<e_errno> & e ) {

  std::cerr <<
    "File read error, errno=" << e.get<e_errno>() << std::endl;

} catch( file_read_error<> & e ) {

  std::cerr << "File read error!" << std::endl;

}
----

That is to say, it is desirable to be able to dispatch error handling based not only on the kind of failure being handled, but also based on the kind of error info available. Unfortunately this syntax is not possible and, even if it were, not all programs use exceptions to handle errors. The result of this train of thought is `<<match,match>>`/`<<unwrap,unwrap>>`.

Last but not least, there is certain redundancy and repetition in error-neutral contexts that simply forward errors to their caller. What is the point in receiving some error info from a lower level function (e.g. a file name), when at this point we can't do anything with it, except to forward it to our caller, until we reach a scope that can actually make use of the data? Even with move semantics, why bother move such data one level at a time, from one stack location to another immediately above, only to move it again when we `return` again?

It is more correct for such information to be passed from a context where it is available, _directly to the exact stack location where it would be accessed by the error handling code_. The result is that `<<expect,expect>>`/`<<put,put>>`/`<<match,match>>` use `thread_local` storage.

[[distribution]]
== Distribution

Copyright (c) 2018 Emil Dotchevski.

LEAF is distributed under the http://www.boost.org/LICENSE_1_0.txt[Boost Software License, Version 1.0].

The source code is available in https://github.com/zajo/leaf[this GitHub repository].

NOTE: LEAF is not part of Boost. Please post questions and feedback on the Boost Developers Mailing List.

[[building]]
== Building

LEAF is a header-only library and it requires no building. The unit tests use Boost Build, but the library itself has no dependency on Boost or any other library.

[[portability]]
== Portability

LEAF requires a {CPP}11 compiler.

See unit test matrix at https://travis-ci.org/zajo/leaf[Travis-CI]. It has also been tested with Microsoft Visual Studio 2015 and 2017.
